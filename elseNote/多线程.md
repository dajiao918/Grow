# 多线程

## 进程和线程

### 程序

* **程序是为了完成特定任务，用某种语言编写的以系列指令组合，即一段静态的代码。**

### 进程

* **是程序的一段执行过程，或是正在运行的程序。是一个动态的过程：有它自身产生，存在，消亡的一个过程。-------生命周期**
* **进程作为资源分配的单位，系统在为每个进程分配不同的内存区域**

### 线程

* **进程可以进一步分化成线程，是一个程序内部的一条之执行路径**
* **线程作为调度和执行的单位，每个线程拥有独立的运行线和程序计数器，线程切换的开销小**
* **一个进程的多个线程共享相同的内存单元/内存地址空间--》它们从同一堆中分配对象，可以访问相同的变量和对象**

### 并行和并发

* **并行：多个CPU执行不同的任务**
* **并发：一个CPU执行多个任务**

## 创建多线程

* **方法①**
  	1. **编写一个类A继承Thread类**
   	2. **重写run()方法**
   	3. **在main()方法实例化类A**
   	4. **调用start()方法**

```java
public class Test{
    public static void main(String[] args){
        MyThread myThread = new MyThread();
        //调用start方法,①：分线程启动  ②：调用run方法
        myThread.start();
        //在主类中遍历质数，和分线程区别
        for(int i = 0; i < 100; i++){
            if(i % 2 != 0){
                System.out.println("主线程" + i);
            }
        } 
    }
}

class MyThread extends Thread{
    
    @Override
    public void run(){
        for(int i = 0; i < 100; i++){
            if(i % 2 == 0){
            	System.out.println("分线程" + i);
            }
        }
    }
}
```

**注意问题：**

* 不能用对象.run()来调用线程
* 一个对象不能调用两次start()方法，必须再次新建一个线程类的对象

练习：

```java
public class Exe {

    public static void main(String[] args) {
        //创建 两个线程，一个遍历100以内的质数，一个遍历100以内的偶数

        //利用匿名子类 的方法是创建
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    //Thread.currentThread()获取当前线程，getName获取线程名
                    if(i % 2 == 0){
                        System.out.println(Thread.currentThread().getName() + ":" + i);
                    }
                }
            }
        }.start();

        //利用匿名子类 的方法创建
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    //Thread.currentThread()获取当前线程，getName获取线程名
                    if(i % 2 != 0){
                        System.out.println(Thread.currentThread().getName() + ":" +  i);
                    }
                }
            }
        }.start();


    }

}
```

### 线程方法：

```java
/**	①：start()执行线程，并执行run()方法
    ②：currentThread()获取当前的线程
    ③：getName()：获取线程的名字
    ④：setName():设置线程的名字
    ⑤：field()，释放CPU的资源
    ⑥：sleep(时间):当前线程睡眠多少时间
    ⑦：join()，在a线程中b线程调用了join()方法，a线程阻塞，直到b线程执行完之后
    ⑧：isAlive():判断当前的线程是否存活
    */

public class MyThread1Test {

    public static void main(String[] args) {
        MyThread1 myThread1 = new MyThread1();
        //给线程设置名字
        myThread1.setName("我的线程");
        //开启线程
        myThread1.start();

        Thread.currentThread().setName("主线程");
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }

            if(i == 20){
                //当i=20的时候，我的线程调用join()方法，主线程阻塞，直到我的线程执行完之后才释放
                try {
                    myThread1.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        //判断我的线程是否还在执行，也就是死了没有
        System.out.println(myThread1.isAlive());
    }

}


//创建我的线程
class MyThread1 extends Thread{

    @Override
    public void run() {
        for(int i=0; i<100; i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }

            if(i % 20 == 0){
                //释放线程的资源
                yield();
            }

            if(i  == 10){
                //当i%10==0时，我的线程睡眠1000毫秒，执行主线程，当主线程执行到了i=20之后，主线程阻塞，
                // 直到我的线程睡眠停止，只想完毕之后主线程才会据需执行
                try {
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
yield()方法只会释放CPU资源，至于下一个是哪个线程执行是不一定的
我的线程:60     我的线程:20
主线程:90       我的线程:22
主线程:92		 我的线程:24
主线程:94		 我的线程:26
主线程:96		 我的线程:28
主线程:98
    
//当i%10==0时，我的线程睡眠1000毫秒，执行主线程，当主线程执行到了i=20之后，主线程阻塞，直到我的线程睡眠停止，然后在执行完毕之后主线程才会继续执行
我的线程:10
主线程:8
主线程:10
主线程:12
主线程:14
主线程:16
主线程:18
主线程:20
我的线程:12
我的线程:14
我的线程:16
```

### 线程的优先级

* 线程的优先级最大是10--MAX-PRIORITY
* 最小线程优先级是1--MIN-PRIORITY
* 默认线程是5
* **线程优先级高意味着抢占CPU的执行权的概率更高，但并不意味着线程优先级高的CPU执行权一定比线程优先级低的CPU执行权更高**

## 创建多线程2：

* 创建一个类A通过实现Runnable接口创建多线程
* 实现run()方法
* main方法中实现类A的实例化
* 然后创建Thread对象，传入参数---A的对象

```java
public class MyThread2Test {

    public static void main(String[] args) {
        MyThread2 myThread2 = new MyThread2();

        Thread thread = new Thread(myThread2);
        //给线程设置名字
        thread.setName("我的线程");
        thread.start();
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + i);
            }
        }

    }

}

class MyThread2 implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + i);
            }
        }
    }
}
```



### 两种创建方法的比较

* **继承Thread类实际上是间接实现Runnable**
* **实现Runnable接口**
  * **避免了单继承的局限性**
  * **便于多个线程共享资源**
* 实现Runnable接口较好一些

### 实例，窗口买票问题

* 继承Thread实现

```java
public class windowTest {

    public static void main(String[] args) {
        Window window1 = new Window();
        Window window2 = new Window();
        Window window3 = new Window();

        window1.setName("窗口一出票");
        window2.setName("窗口二出票");
        window3.setName("窗口三出票");

        window1.start();
        window2.start();
        window3.start();
    }

}

class Window extends Thread{
    //共享票数
    private static int ticket = 100;

    @Override
    public void run() {

        while(true){

            if(ticket > 0){
                System.out.println(getName() + ":" + ticket);
                ticket--;
            }
        }

    }
}
```

* 实现Runnable接口实现

```java
public class WindowTestByRunnable {

    public static void main(String[] args) {
        Window1 window1 = new Window1();

        Thread thread1 = new Thread(window1);
        Thread thread2 = new Thread(window1);
        Thread thread3 = new Thread(window1);

        thread1.setName("窗口一出票");
        thread2.setName("窗口二出票");
        thread3.setName("窗口三出票");

        thread1.start();
        thread2.start();
        thread3.start();
    }

}

class Window1 implements Runnable{

    //不用设置为static，因为此时是三个Thread对象共享一个window1对象
    private int ticket = 100;

    @Override
    public void run() {
        while(true){

            if(ticket > 0){
                System.out.println(Thread.currentThread().getName() + ":" + ticket);
                ticket--;
            }
        }
    }
}
```

