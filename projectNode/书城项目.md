# 书城项目

## Dao层的编写

### JDBC连接池

* 这个不需多说，连接数据库的必要操作，首先导包
  * mysql-connector-java-8.0.21.jar
  * druid-1.1.9.jar
  * 还要有一个properties配置文件，用来获取mysql的协议，URL，密码，用户等

```java
import com.alibaba.druid.pool.DruidDataSourceFactory;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;

pubilc class JDBCUtils{
    private static DataSource datasource = null;
    
    //类加载之后就记载，获取连接池
    static{
        Properties properties = new Properties();
        try{
            //加载配置文件
            properties.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
            //利用Druid连接池工厂类初始化驱动
            dataSource = DruidDataSourceFactory.createDataSource(properties);
        } catch(Exception e){
            e.printStackTrace();
        }
    }
    
    //获取连接方法
    public static Connection getConnection{
        Connection connection = null;
        try{
           connection = dataSource.getConnection(); 
        }
         catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        return connection
    }
    
    //关闭连接方法
     public static void close(Connection connection){

        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
```



### DbUtils的增删改查

​	

​	CRUD基本上是必然操作，所以编写底层的增删改查基本是项目开场即做的事

* 导包
  * commons-dbutils-1.3.jar

```java
package com.dajiao.dao;

import com.dajiao.utils.JDBCUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @program: book
 * @description:
 * @author: Mr.Yu
 * @create: 2020-12-10 22:09
 **/
public class BasicDao {

    QueryRunner queryRunner = new QueryRunner();

    public int update(String sql, Object...params){

        Connection connection = JDBCUtils.getConnection();
        try {
            int update = queryRunner.update(connection, sql, params);
            return update;
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JDBCUtils.close(connection);
        }

        return -1;
    }

    public <T> T querySingle(String sql,Class<T> c, Object...params) {

        Connection connection = null;
        try {
            connection = JDBCUtils.getConnection();
            T query = queryRunner.query(connection, sql, new BeanHandler<>(c), params);
            return query;
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JDBCUtils.close(connection);
        }
        return null;
    }

    public <T> List<T> queryMul(String sql, Class<T> c, Object...params) {
        Connection connection = null;
        try {
            connection = JDBCUtils.getConnection();
            List<T> query = queryRunner.query(connection, sql, new BeanListHandler<>(c), params);
            return query;
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JDBCUtils.close(connection);
        }

        return null;
    }

    public Object querySal(String sql,Object...params) {

        Connection connection = null;
        try {
            connection = JDBCUtils.getConnection();
            Object query = queryRunner.query(connection, sql, new ScalarHandler(), params);
            return query;
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JDBCUtils.close(connection);
        }

        return null;
    }

}

```

## 

## 注册功能

### 验证输入合法性

* 以下功能在regist.jsp页面下完成

```javascript
$(function (){
			let patt = /^\w{5,12}$/;
			$("#sub_btn").click(function (){
				let usernameVal = $("#username").val();
				if (!patt.test(usernameVal)) {
					$(".errorMsg").text("用户名不合法");
					return false;
				}
				let passwordVal = $("#password").val();
				if (!patt.test(passwordVal)) {
					$(".errorMsg").text("密码不合法");
					return false;
				}
				let repwd = $("#repwd").val();
				if (repwd != passwordVal) {
					$(".errorMsg").text("密码不一致");
					return false;
				}
				let codeVal = $("#code").val();
				if (codeVal == null || codeVal == "") {
					$(".errorMsg").text("验证码不合法");
					return false;
				}
			});
			$(".errorMsg").text("");
		})
```

### 使用谷歌验证码

* 导包

  * kaptcha-2.3.2.jar

* 配置web.xml地址

  ```xml
  servlet>
          <servlet-name>KaptchaServlet</servlet-name>
          <servlet-class>com.google.code.kaptcha.servlet.KaptchaServlet</servlet-class>
  </servlet>
  <servlet-mapping>
          <servlet-name>KaptchaServlet</servlet-name>
          <url-pattern>/kaptchaServlet</url-pattern> 
  </servlet-mapping>
  ```

* 在验证码图片路径src="kaptchaServlet";

* 编写验证码点击事件，随时更新验证码

  ```javascript
  $("#sureCode").click(function (){
      //JavaScript单击事件中会有一个this对象，这个对象是正在响应当前事件的dom对象，也就是代表了标签
  	//this.src代表了此标签的路径，d=new Date()是为了让每次请求的参数都不一样，防止服务器缓存，每次都调用同一张图片
  	this.src = "${requestScope.basePath}kaptchaServlet?d=" + new Date();
  })
  ```

  

## 注册和登录实现



​	二话不说，先创建一个用户的数据库表

```sql
CREATE TABLE t_user(
    id INT PRIMARY   #ID号，主键
    username VARCHAR(20) UNIQUE,  #用户名，不可重复
    password VARCHAR(20),    #密码
    email  VARCHAR(20)   #邮箱
)
```



​	创建pojo实体类

```java
public class User {

    private Integer id;
    private String username;
    private String password;
    private String email;

    public User() {
    }

    public User(Integer id, String username, String password, String email) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
    }
    
    .....get/set/toString
}
```



* 注册分两种情况

  * 注册成功
    * 怎么才算是注册成功呢？
      1. 各种输入合法（用户名，密码等）
      2. 验证码正确
         * 获取验证码参数，获取谷歌验证码比较即可
      3. 用户名不重复
         * 使用业务层方法判断existUser()
    * 注册成功又该做些什么？
      1. 保存用户信息
         * 使用业务层方法saveUser()
      2. 跳转到注册成功页面
         * 请求转发
  * 注册失败
    * 怎么才算是注册失败呢？
      1. 验证码不正确
      2. 用户名重复
    * 注册失败又该做些什么呢？
      1. 失败之后信息的回显，比如用户名的回显，邮箱的回显
         * 使用request域保存用户名和邮箱，在jsp页面中使用EL表达式输出
      2. 提示用户失败的原因
         * 使用request域保存失败原因，在jsp页面中使用EL表达式输出

  * 代码实现

  ```java
  Dao层：
      //用于判断用户名是否存在
      public User getUserByName(String username) {
          String sql = "select * from t_user where username = ?";
          User user = querySingle(sql, User.class, username);
          return user;
      }
  
  	//用于注册成功后保存用户
  	public int saveUser(User user) {
          String sql = "insert into t_user values(?,?,?,?)";
          return update(sql,user.getId(),user.getUsername(),user.getPassword(),user.getEmail());
      }
  
  service层：
      //用于判断用户名是否存在
      public boolean existUser(String username) {
          User user = userDao.getUserByName(username);
          if (user == null){
              return true;
          } else {
              return false;
          }
      }
  
      public int saveUser(User user) {
              int i = userDao.saveUser(user);
              return i;
         }
  
  //注册方法
      protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          //获取谷歌验证码
          String attribute = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);
          //立即删除session中的验证码
          req.getSession().invalidate();
          //获取user对象
          User user = WebUtils.copyParamToBean(req.getParameterMap(), new User());
          //获取验证码参数
          String code = req.getParameter("code");
          if (attribute.equals(code) && attribute != null) {
              if (userService.existUser(user.getUsername())) {
                  //代表用户名没有重复
                  //保存用户的信息
                  userService.saveUser(user);
                  req.getRequestDispatcher("/pages/user/regist_success.jsp").forward(req, resp);
              } else {
                  //代表用户名重复
                  req.setAttribute("msg", "用户名已存在");
                  //需要回显  信息
                  req.setAttribute("username", user.getUsername());
                  req.setAttribute("email", user.getEmail());
                  //跳回注册页面
                  req.getRequestDispatcher("/pages/user/regist.jsp").forward(req,resp);
              }
          } else {
              //设置错误信息
              req.setAttribute("msg","验证码错误");
              //表单回显
              req.setAttribute("username", user.getUsername());
              req.setAttribute("email", user.getEmail());
              req.getRequestDispatcher("/pages/user/regist.jsp").foward(req,resp);
          }
      }
  ```

  * 同样，登录分两种情况

    * 登录成功

      * 登录成功之后需要做些什么呢

        1. 跳转到登录成功页面
           * 需要用到请求转发

      * 怎么才算登录成功呢

        1. 获取参数
           * 使用request.Parameter()方法获取

        2. 用户名和密码匹配，必须两者一起匹配才行

        * 需要使用业务层方法login()

    * 登录失败

      * 怎么才算登录失败呢？
        1. 用户名和密码不匹配
           * 需要使用业务层方法login()
      * 登录失败应该做些什么呢？
        1. 提示用户失败原因
           * 使用reqest域保存错误信息，EL表达式输出
        2. 用户信息回显
           * 使用reqest域保存用户信息，EL表达式输出

* 代码实现

```java
Dao层：
    public User getUserByNameAndPassword(String username, String password) {
        String sql = "select * from t_user where username = ? and password = ?";
        User user = querySingle(sql, User.class, username,password);
        return user;
    }
    
service层：
    public User login(String username, String password) {
        return userDao.getUserByNameAndPassword(username, password);
    }

web层：
protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        User user = userService.login(username, password);

        //验证登录情况
        if (user != null) {
            //成功使用session域保存当前用户信息
            req.getSession().setAttribute("user",user);
            //跳转到登录成功页面
            req.getRequestDispatcher("/pages/user/login_success.jsp").forward(req,resp);
        } else {
            //失败，保存表单信息，用于回显
            req.setAttribute("username",username);
            //保存失败原因
            req.setAttribute("msg","用户名或密码错误");
            //跳回原页面
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req,resp);
        }
}
```

## 管理书籍的CRUD



​	管理书籍，二话不说，先在数据库中创建一个存储书籍的表

```sql
CREATE TABLE T_BOOK(
	id INT PRIMARY KEY,   #图书编号，主键
    name VARCHAR(20) UNIQUE,	#书名，唯一
    price DOUBLE,	#价格
    author VARCHAR(20),		#作者
    sales INT,		#销量
    stock INT,		#库存
    img_path PHOTO 	#书的图片
)
```



​	数据库里面有t_book，那么pojo实体类肯定是要有的book

```java
public class Book {

    private Integer id;
    private String name;
    private Double price;
    private String author;
    private Integer sales;
    private Integer stock;
    private String img_path = "/static/img/default.jpg";

    public Book() {
    }

    public Book(Integer id, String name, Double price, String author, Integer sales, Integer stock, String img_path) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.author = author;
        this.sales = sales;
        this.stock = stock;
        //为了简洁，图片就这一张了
        if (img_path == null) {
            this.img_path = "/static/img/default.jpg";
        }
    }

....get/set/toString
}
```



* 问题1：当点击超链接[图书管理]()时，是要看到图书列表的，如何显示图书列表呢？

  * 点击超链接之后，进入BookServlet程序，进行图书遍历方法实现

  * 这时问题又来了，怎么在Servlet程序实现图书的遍历呢？
    * 我们知道，图书是在数据库中存放的，想要遍历图书，必须访问数据库
    
    ```sql
    select * from t_book
    ```
    
    * servlet程序------》service业务层---------》实体Dao层
    
  * 问题1.2，图书遍历方法实现了，怎么在页面中显示呢？
    1. 首先需要将图书信息保存进request域中
    2. 在jsp页面上，使用JSTL标签的 for Each语句循环输出

  ```java
  Dao层：
      public List<Book> list() {
  
          String sql = "select * from t_book";
          List<Book> books = queryMul(sql, Book.class);
          return books;
      }
  
  service层：
      public List<Book> list() {
          return bookDao.list();
      }
  
  web层：
  //点击超链接之后，由此方法执行在将数据传输给jsp页面，由jsp页面遍历输出
  protected void bookList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  
          List<Book> books = bookService.list();
      //书的数据源
          request.setAttribute("books",books);
          System.out.println(request.getContextPath());
          request.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(request,response);
      }
  //jsp页面中的遍历输出
  <c:forEach items="${requestScope.books}" var="book" >
  	<tr>
  		<td>${book.name}</td>
  		<td>${book.price}</td>
  		<td>${book.author}</td>
  		<td>${book.sales}</td>
  		<td>${book.stock}</td>
  		<td><a href="book_edit.jsp">修改</a></td>
      													//传书的编号，利于删除和修改
  		<td ><a href="bookServlet?action=delete&bookId=${book.id}" class="deleteBook">删除</a></td>
  	</tr>
  </c:forEach>
  ```

  

* 问题二：当图书列表显示出来后，怎么实现删除方法呢？

  * 其实具体步骤跟上面一样一样的
    1. 点击超链接之后，进入BookServlet程序，进行图书删除方法实现
    2. 需要获取删除的图书编号，有图书编号进行删除方法
    3. servlet程序------》service业务层---------》实体Dao层
    4. 利用重定向进入bookServlet的bookList方法，简单来说就是刷新列表
    5. 需要注意一个细节，删除是根据id删的，所以需要在删除超链接上传一个id的参数

  ```java
  Dao层：
      public int deleteById(Integer id) {
          String sql = "delete from t_book where id = ?";
          return update(sql, id);
      }
  
  service层：
      public int delete(Integer id) {
          return bookDao.deleteById(id);
      }
  
  web层：
  //点击超链接后，进入此方法处理业务
  protected void delete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  
          //获取要删除的图书id
          int bookId = WebUtils.parseInt(request.getParameter("bookId"), 0);
          bookService.delete(bookId);
          //刷新列表
          response.sendRedirect(request.getContextPath() + "/bookServlet?action=bookList");
      	//或者直接调用booklist，相当于请求转发
      	//bookList(request,response);
      }
  ```

* 问题三：怎么实现修改图书信息方法呢？

  * 首先点击超链接之后，会进入修改页面，第一个问题就是如何显示图书信息？

    * 注意，这时显示图书的信息只有一本图书，那怎么样才能知道要显示哪一本图书呢？
    * 这时就要传输一个参数--------图书的编号

    ```jsp
    <td><a href="bookServlet?action=getBook&bookId=${book.id}">修改</a></td>
    ```

    ```java
    Dao层：
        public Book queryBookById(Integer id) {
            String sql = "select * from t_book where id = ?";
            return querySingle(sql,Book.class,id);
        }
    
    service层：
        public Book getBookById(Integer id) {
          return bookDao.queryBookById(id);
        }
    
    web层：
    protected void getBook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            //获取图书id进行图书信息的显示
            int bookId = WebUtils.parseInt(request.getParameter("bookId"), 0);
            Book book = bookService.getBookById(bookId);
            request.setAttribute("book",book);
          request.getRequestDispatcher("/pages/manager/book_edit.jsp").forward(request,response);
        }
    ```
    
    ```jsp
    //在jsp页面上进行输出
    <td><input name="book_name" type="text" value="${requestScope.book.name}"/></td>
    						<td><input name="book_price" type="text" value="${requestScope.book.price}"/></td>
  						<td><input name="book_author" type="text" value="${requestScope.book.author}"/></td>
    						<td><input name="book_sales" type="text" value="${requestScope.book.sales}"/></td>
    						<td><input name="book_stock" type="text" value="${requestScope.book.stock}"/></td>
    ```
    
    * 然后，再进行对图书修改，显然需要操作数据库
    * 于是servlet程序------》service业务层---------》实体Dao层
    * 这里有一个细节，修改显然是对图书整体进行修改，所以这里servlet程序修改时的方法显然要将图书的封装成对象，传入方法中，进行整体修改，而修改时需要的条件就是图书的编号，因为图书编号是不需要也不能更改的。
    * 再请求转发或者重定向执行bookList方法刷新列表即可
      * **犯了两个错误**
      1. **表单提交时的方法参数不应该在form标签的action属性后添加，应该在表单中加一个隐藏input标签**
        2. **获取参数封装对象时，表单的name属性值一定要和实体类的属性一一对应**
    
    ```java
    Dao层：
        public int updateBook(Book book) {
            String sql = "update t_book set name = ?, price = ?,sales = ?,stock = ? where id = ?";
            return update(sql,book.getName(),book.getPrice(),book.getSales(),book.getStock(),book.getId());
        }
    
    service层：
        public int update(Book book) {
            return bookDao.updateBook(book);
        }
    
    web层：
    protected void update(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            //获取图书的所有信息，封装成book对象，用于修改
            String name = request.getParameter("book_name");
            Book book = WebUtils.copyParamToBean(request.getParameterMap(), new Book());
            bookService.update(book);
            request.getRequestDispatcher("/bookServlet?action=bookList").forward(request,response);
        }
    ```
    
    

* 问题四：怎么实现增加方法呢？

  1. 因为增加图书方法和修改图书方法最终进入的是一个页面，都是需要点击提交按钮来提交表单的，那么问题来了，点击提交按钮之后，servlet程序怎么知道你是想要修改图书还是增加图书呢？

     * 方法一：由上面的分析我们知道，[修改]()的时候是需要传图书的id的，而[增加]()图书的时候是没有的，所以只需要在jsp页面中判断id是否为空即可
     * 方法二：[修改]()图书和[增加]()图书是两个不同的请求，修改图书时request域中需要保存图书信息，而增加图书时request域中没有图书信息，所以只需要判断request域中图书信息是否为空即可
     * 方法三：只需要在点击[修改]()和[增加]()图书的超链接上加上一个参数action=add/action=update即可

     ```jsp
     方法一：<input type="hidden" name="action" value="${emety requestScope.book.id?"add":"update"}"
     方法二：<input type="hidden" name="action" value="${emety requestScope.book?:"add":"update"}"
     方法三：
     	<a href="bookServlet?action=getBook&bookId=${requestScope.book.id}&method=update">修改</a>
     	<a href="pages/manager/book_edit.jsp?method=add">增加</a>
     ```

  2. 点击超链接之后，进入BookServlet程序，进行图书增加方法实现

  3. servlet程序------》service业务层---------》实体Dao层

  ```java
  Dao层：
      public int addBook(Book book) {
  
          String sql = "insert into t_book(id,name,author,price,sales,stock,img_path) values(?,?,?,?,?,?,?)";
          return update(sql,null,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImg_path());
  
      }
  
service层：
      public int addBook(Book book) {
          return bookDao.addBook(book);
      }
  
  web层：
  protected void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  
          //获取图书的所有信息，封装成book对象
          Book book = WebUtils.copyParamToBean(request.getParameterMap(), new Book());
          bookService.addBook(book);
          request.getRequestDispatcher("/bookServlet?action=bookList").forward(request,response);
      }
  ```
  
  

### 对书籍管理页面的分页

* 这里我们只分五页，那么有哪几种情况呢？
  * 当页面有1-5页时
    * 只有1-5页，只需要显示1，2，3，4，5
  * 当页面超过五页时
    * 当前页小于等于3时
      * 1，2，3，4，5
    * 当前页  >=（最后一页-3时），比如当前总共有20页，当前页就可能是18，19，20
      * 16，17，18，19，20
    * 其他情况
      * 当前页-2，当前页-1，当前页，当前页+1，当前页+2
* 以上就是分页的情况了

```jsp
<a href="#">首页</a>
<a href="#">上一页</a>
<a href="#">3</a>
【4】
<a href="#">5</a>
<a href="#">下一页</a>
<a href="#">末页</a>
共10页，30条记录 到第<input value="4" name="pn" id="pn_input"/>页
```

* 现在就进入到另外的问题了，如何实现分页？

  * 捋一捋思路，当管理员点击图书管理后，需要看到分好页的界面，所以我们需要在点击时跳转到servlet程序进行分页。

  * 分页，无非就是每一页都有一个不同的数据源，遍历显示图书，那么怎么获得不同的数据源呢？

    * 那当然是利用SQL语句： select * from t_book limit begin , size

  * begin是开始索引，size是当前页的数量，那么问题又来了，怎么样才能直到begin和size呢？

    * size可以是固定的，那begin呢？

      ```java
      pageNo		pageSize		begin
      1			4				0
      2			4				4
      3			4				8
      begin=(pageNo-1)*pageSize //pageNo是当前页，pageSize是当前页的数据量
      ```

  * 那么现在就可以对页面进行初步的分页编写

  ```java
  Dao层
       @Override
      public List<Book> pageTest(Integer begin, Integer size) {
          String sql = "select * from t_book limit ?,?";
          return queryMul(sql, Book.class, begin, size);
      }
  Service层
       @Override
      public List<Book> page(Integer pageNo,Integer  pageSize) {
          int begin = (pageNo-1)*pageSize;
          return bookDao.pageTest(begin,pageSize);
      }
  web层
       protected void page(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          int pageNo = WebUtils.parseInt(request.getParameter("pageNo"), 1);
          int pageSize = 4;
          List<Book> pageBooks = bookService.page(pageNo, pageSize);
          request.setAttribute("pageBooks",pageBooks);
          request.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(request,response);
      }
  ```

  

  * 看起来好像是已经可以了，那么我们试想一下，当点击下一页时，我们需要传入下一页的参数给servlet程序，此时在jsp页面中，我们只有pageBooks的数据，也就是数据源，没有其他的数据，是不能给servlet程序传pageNo这个参数的，那么难道还是要在request域中存储一个pageNo传输过来吗？那么到达尾页呢？还是由request传输吗？
  * 显然这是有点麻烦的，现在我们要传输，pageBooks，pageNo，pageTotal，那么我们是否可以讲这些东西封装成对象处理呢？答案是显然的。

  ```java 
  pojo实体类，page分页模型
  public class page{
      //每页数量
      private static Integer pageSize = 4;
      //当前页码
      private Integer pageNo;
      //总的数据数量
      private Integer pageTotalCount;
      //总的页数
      private Integer pageTotal;
      //数据源
      private List<T> pageBooks;
  
      public page() {
      }
  
      public page(Integer pageNo, Integer pageTotalCount, Integer pageTotal, List<T> pageBooks) {
          this.pageNo = pageNo;
          this.pageTotalCount = pageTotalCount;
          this.pageTotal = pageTotal;
          this.pageBooks = pageBooks;
      }
  
      public static Integer getPageSize() {
          return pageSize;
      }
  
      public static void setPageSize(Integer pageSize) {
          page.pageSize = pageSize;
      }
  
      public Integer getPageNo() {
          return pageNo;
      }
  
      public void setPageNo(Integer pageNo) {
          this.pageNo = pageNo;
      }
  
      public Integer getPageTotalCount() {
          return pageTotalCount;
      }
  
      public void setPageTotalCount(Integer pageTotalCount) {
          this.pageTotalCount = pageTotalCount;
      }
  
      public Integer getPageTotal() {
          return pageTotal;
      }
  
      public void setPageTotal(Integer pageTotal) {
          this.pageTotal = pageTotal;
      }
  
      public List<T> getPageBooks() {
          return pageBooks;
      }
  
      public void setPageBooks(List<T> pageBooks) {
          this.pageBooks = pageBooks;
      }
  
      @Override
      public String toString() {
          return "page{" +
                  "pageNo=" + pageNo +
                  ", pageTotalCount=" + pageTotalCount +
                  ", pageTotal=" + pageTotal +
                  ", pageBooks=" + pageBooks +
                  '}';
      }
  }
  ```

* 于是我们就需要重新实现代码

```java
Dao层：
    @Override
    public List<Book> pageTest(Integer begin, Integer size) {

        String sql = "select * from t_book limit ?,?";
        return queryMul(sql, Book.class, begin, size);
    }

    @Override
    public Integer queryForPageTotalCount() {
        String sql = "select count(*) from t_book";
        Number number = (Number) querySal(sql);
        return number.intValue();
    }
Service层：
    @Override
    public Page page(Integer pageNo, Integer  pageSize) {
        //获取索引
        int begin = (pageNo-1)*pageSize;
        //获取总的数据量
        Integer pageTotalCount = bookDao.queryForPageTotalCount();
        //获取总的页数
        Integer pageTotal = pageTotalCount / pageSize;
        if (pageTotalCount % pageSize != 0){
            pageTotal = pageTotal + 1;
        }
        List<Book> pageBooks = bookDao.pageTest(begin, pageSize);
        Page<Book> page = new Page<>(pageNo, pageTotalCount, pageTotal, pageBooks);
        return page;
    }
web层：
    protected void page(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        int pageNo = WebUtils.parseInt(request.getParameter("pageNo"), 1);
        int pageSize = Page.getPageSize();
        Page page = bookService.page(pageNo, pageSize);
        request.setAttribute("page",page);
        request.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(request,response);
    }
```

* 实现首页，尾页

  * 实现首页和尾页只需要在地址上改变即可

    ```html
    <a href="bookServlet?action=page&pageNo=${requestScope.page.pageNo}">首页</a>
    <a href="bookServlet?action=page&pageNo=${requestScope.page.pageTotal}">尾页</a>
    ```

* 实现上一页，下一页

  ```html
  <!--当然也不是什么时候都有上一页的，需要排除当前页是第一页的情况-->
  <c:if test="${requestScope.page.pageNo > 1}">
  	<a href="bookServlet?action=page&pageNo=${requestScope.page.pageNo-1}">上一页</a>	
  </c:if>
  <c:if test="${requestScope.page.pageNo < requestScopepage.pageTotal}">
  	<a href="bookServlet?action=page&pageNo=${requestScope.page.pageNo+1}">下一页</a>	
  </c:if>
  ```

* 实现五个页面的跳转

```html
</%----%>
<c:if test="${requestScope.page.pageNo > 1}">
	<a href="bookServlet?action=page&pageNo=1">首页</a>
	<a href="bookServlet?action=page&pageNo=${requestScope.page.pageNo-1}">上一页</a>
</c:if>
<%--当总页数小于5时--%>
<c:if test="${requestScope.page.pageTotal <= 5}">
	<c:forEach begin="1" end="${requestScope.page.pageTotal}" var="i">
		<c:if test="${i == requestScope.page.pageNo}">
			【${i}】
		</c:if>
		<c:if test="${i != requestScope.page.pageNo}">
			<a href="bookServlet?action=page&pageNo=${i}">${i}</a>
		</c:if>
	</c:forEach>
</c:if>
    <%--当总页数大于5时--%>
<c:if test="${requestScope.page.pageTotal > 5}">
	<c:choose>
        <%--当当前页数小于3时--%>
		<c:when test="${requestScope.page.pageNo <= 3}">
			<c:forEach begin="1" end="5" var="i" >
                <%--如果是当前页--%>
				<c:if test="${i == requestScope.page.pageNo}">
					【${i}】
				</c:if>
                <%--如果不是当前页，需要跳转的路径，和方法参数，还有页的参数--%>
				<c:if test="${i != requestScope.page.pageNo}">
					<a href="bookServlet?action=page&pageNo=${i}">${i}</a>
				</c:if>
			</c:forEach>
		</c:when>
         <%--当 当前页 > 总页数-3 --%>
		<c:when test="${requestScope.page.pageNo > (requestScope.page.pageTotal - 3)}">
		<c:forEach begin="${requestScope.page.pageTotal - 4}end="${requestScope.page.pageTotal}" var="i">
				<c:if test="${i == requestScope.page.pageNo}">
					【${i}】
				</c:if>
				<c:if test="${i != requestScope.page.pageNo}">
					<a href="bookServlet?action=page&pageNo=${i}">${i}</a>
				</c:if>
		</c:forEach>
		</c:when>
			<c:otherwise>
          <%--其他情况--%>
		<c:forEach begin="${requestScope.page.pageNo - 2}" end="${requestScope.page.pageNo + 2}" var="i">
						<c:if test="${i == requestScope.page.pageNo}">
							【${i}】
						</c:if>
						<c:if test="${i != requestScope.page.pageNo}">
							<a href="bookServlet?action=page&pageNo=${i}">${i}</a>
						</c:if>
					</c:forEach>
				</c:otherwise>
			</c:choose>
		</c:if>
		<c:if test="${requestScope.page.pageNo < requestScope.page.pageTotal}">
			<a href="bookServlet?action=page&pageNo=${requestScope.page.pageNo+1}">下一页</a>
			<a href="bookServlet?action=page&pageNo=${requestScope.page.pageTotal}">末页</a>
</c:if>
```

* 实现具体某一页的跳转
* 这里需要具体说明一个问题，输入框是可以接受任何数字的，当有些用户恶意的输入很大，或者是负数时，就会造成一些bug，所以我们应该防止这种情况的发生，代码实现：

```javascript
到第<input value="${requestScope.page.pageNo}" name="pn" id="pn_input"/>页
<input type="button" class="btn_page" value="确定">
    
    <script type="text/javascript">

				$(function (){
					$(".btn_page").click(function (){
						let pageNo = $("#pn_input").val();
						// alert(pageNo);
                        //判断用户输入的合法性
						if (pageNo > ${requestScope.page.pageTotal}) {
							pageNo = ${requestScope.page.pageTotal};
						} else if (pageNo < 1){
							pageNo = 1;
						}
                        //根据location属性跳转到输入的页面
						location.href= "${requestScope.basePath}bookServlet?action=page&pageNo=" + pageNo;
					})
				})

	</script>
```

* 当然，上面的数据边境检测确实是对输入框进行了限制，但是，有经验的人就会知道，在地址栏上直接改pageNo的页数，这样就又造成了bug，例如，在地址栏上敲：

```html
http://localhost:8080/book/bookServlet?action=page&pageNo=20
```

* 这样是不会经过jsp页面的，直接进入servlet程序进行分页，所以我们需要在形成page对象前进行检测

```java
//对service层的修改
@Override
    public Page page(Integer pageNo, Integer  pageSize) {
        //获取总的数据量
        Integer pageTotalCount = bookDao.queryForPageTotalCount();
        //获取总的页数
        Integer pageTotal = pageTotalCount / pageSize;
        if (pageTotalCount % pageSize != 0){
            pageTotal = pageTotal + 1;
        }
        //数据边境检测
        if (pageNo > pageTotal) {
            pageNo = pageTotal;
        }
        if (pageNo < 1){
            pageNo = 1;
        }
        //获取索引
        int begin = (pageNo-1)*pageSize;
        List<Book> pageBooks = bookDao.pageTest(begin, pageSize);
        Page<Book> page = new Page<>(pageNo, pageTotalCount, pageTotal, pageBooks);
        return page;
    }
```



### 修改分页之后的bug

* 当我们在分页之后，原先的增删改功能还是跳转到没有分页的方法

```jsp
//原来遍历图书，数据源是${requestScope.books}
//现在遍历图书，数据源是${requesrScope,page.pageBooks}
```

* 因此当我们修改或者添加，删除图书之后，会跳转到以前的方法，导致页面没有数据显示，所以需要修改跳转的地址
* 要回到原来的页数，那肯定是要获取pageNo参数的



* 解决修改图书bug：

  1. 在修改的超链接上传入pageNo参数

  ```jsp
  <td><a href="bookServlet?action=getBook&bookId=${book.id}&pageNo=${requestScope.page.pageNo}">修改</a></td>
  ```

  2. 在修改图书页面上也要加一个隐藏域，传入pageNo参数

  ```jsp
  <input type="hidden" name="pageNo" value="${param.pageNo}"/>
  ```

  3. 在servlet程序获取pageNo参数，然后修改请求转发的地址为

  ```
  "/bookServlet?action=page&pageNo=" + pageNo
  ```



* 解决增加图书的bug

  1. 在增加的超链接上传入pageNo参数

  ```jsp
  //这里肯定是传最后一页
  <td><a href="pages/manager/book_edit.jsp?pageNo=${requestScope.page.pageTotal}">添加图书</a></td>
  ```

  2. 增加隐藏域，上面已完成
  3. 在servlet程序中获取参数，并将pageNo+1

  ``` 
  //pageNo加一页，防止了一种情况：图书添加后页数刚好增加，会跳转到前一页的情况。而没有这种情况也无所谓，因为做了数据边境的检测
  "/bookServlet?action=page&pageNo=" + (pageNo + 1)
  ```



* 解决删除图书的bug

  1. 在删除的超链接上传入pageNo参数

  ```jsp
  <td ><a href="bookServlet?action=delete&bookId=${book.id}&pageNo=${requestScope.page.pageNo}" class="deleteBook">删除</a></td>
  ```

  2. 在servlet程序中修改地址即可

  ```java
  "bookServlet?action=page&pageNo=" + pageNo
  ```

  

## 实现前台分页

* 第一步还是跟后台一样，进行图书的遍历，将图书显示在前台页面上，所以第一时间还是要编写servlet程序---ClientServlet
* 这里又有一个细节了，前台页面是在index.jsp，是启动服务器访问的第一个页面，也就是在地址栏输入到工程路径为止访问的页面，所以又跳出来一个问题，怎么样才能进入ClientServlet程序对前台进行图书遍历并分页呢？
* 只需要使用jsp的请求转发标签即可

```jsp
<jsp:forward page="clientServlet?action=page"></jsp:forward>
```

* 遍历程序基本一样

```java
protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //获取pageNo参数
        int pageNo = WebUtils.parseInt(req.getParameter("pageNo"), 1);
        int pageSize = Page.getPageSize();
        Page page = bookService.page(pageNo, pageSize);
        req.setAttribute("page",page);
        req.getRequestDispatcher("/pages/client/index.jsp").forward(req,resp);
    }
```

* 分页程序也是一样的，当然，这里是有一个小问题的，因为上面的分页都是针对后台的，后台是有自己的servlet程序的，和前台的访问地址是不同的，难道我们要在不同的页面上都写相同的分页jsp程序，然后只是访问地址不同吗？这会造成大量的代码冗余。
* 解决方法就是给page对象添加一个属性---URL，然后在page对象传输前给url设置值即可

```java
private String url = "";


public String getUrl() {
   return url;
}

public void setUrl(String url) {
    this.url = url;
}

//在bookServlet中修改url的值
Page page = bookService.page(pageNo, pageSize);
page.setUrl("bookServlet?action=page");
request.setAttribute("page",page);

//在clientServlet中修改url的值
Page page = bookService.page(pageNo, pageSize);
page.setUrl("clientServlet?action=page");
req.setAttribute("page",page);
```

### 根据价格对书籍分页

* 根据价格对书籍进行分页无非还是两件事

  1. 获取价格区间的图书源
  2. 对当前价格区间进行分页

* 第二个问题是显而易见的答案还是一样的，但是如何获取规定价格之间的图书呢？

  * 我们知道，获取图书，是要访问数据库的，而获取规定价格之间的图书也是不例外。

  ```sql
  //获取图书
  select * from t_book where price between minPrice and maxPrice order by price limit begin,pageSize
  //获取图书总数量
  select count(*) from t_book where price between minPrice and maxPrice
  ```

  * 所以还是由servlet程序---》service层-----》Dao层

```java
Dao层
     @Override
    public Integer queryForPageTotalCountByPrice(Integer min, Integer max) {
        String sql = "select count(*) from t_book where price between ? and ?";
        Number number = (Number) querySal(sql, min, max);
        return number.intValue();
    }

    @Override
    public List<Book> queryBookByPrice(int min, int max, int begin, int pageSize) {
        String sql = "select * from t_book where price between ? and ? order by price limit ?,?";
        List<Book> books = queryMul(sql, Book.class, min, max, begin, pageSize);
        return books;
    }

service层：
     @Override
    public Page pageByPrice(int min, int max, int pageNo, int pageSize) {
        //获取总的数据量
        Integer pageTotalCount = bookDao.queryForPageTotalCountByPrice(min, max);
        Integer pageTotal = pageTotalCount / pageSize;
        if (pageTotalCount % pageSize != 0){
            pageTotal = pageTotal + 1;
        }
        if (pageNo > pageTotal) {
            pageNo = pageTotal;
        }
        if (pageNo < 1){
            pageNo = 1;
        }
        //获取索引
        int begin = (pageNo-1)*pageSize;
        //获取总的页数
        List<Book> pageBooks = bookDao.queryBookByPrice(min, max, begin, pageSize);
        Page<Book> page = new Page<>(pageNo, pageTotalCount, pageTotal, pageBooks);
        return page;
    }

web层：
    protected void pageByPrice(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //获取pageNo参数
        int min = WebUtils.parseInt(req.getParameter("min"), 0);
        int max = WebUtils.parseInt(req.getParameter("max"), Integer.MAX_VALUE);
        System.out.println(req.getParameter("max"));
        int pageNo = WebUtils.parseInt(req.getParameter("pageNo"), 1);
        int pageSize = Page.getPageSize();
        Page page = bookService.pageByPrice(min, max, pageNo, pageSize);
        StringBuilder sb = new StringBuilder("clientServlet?action=pageByPrice");
        sb.append("&min=" + req.getParameter("min"));
        sb.append("&max=" + req.getParameter("max"));
        page.setUrl(sb.toString());
        req.setAttribute("page",page);
        req.getRequestDispatcher("/pages/client/index.jsp").forward(req,resp);
    }
```

​	这里还是有一个小问题的，当根据价格分页后，点击下一页时会出现一个小bug，因为[下一页]()是一个超链接，是不会带上表单中的价格数据的，所以我们需要手动的在clientServlet程序中将min和max的参数传递给jsp页面，以便点击的时候带上价格参数。



## 购物车的实现

​	首先购物车，这毫无疑问以java的视角看过去，那肯定是一个对象了，现在我们无非就是分析有哪些属性和方法了

* 购物车嘛，就是装商品的呗，各类图书的结合体



​	所以还要创建一个商品模型对象，因为用户购买图书是有可能购买多种图书的

1. id
2. 图书名称
3. 图书单品价格
4. 图书总数量
5. 必须有一个可以获取总价格的方法

//商品类

``` java
public class CartItem {

    private Integer id;
    private String name;
    private Double price;
    private Integer ToTalCount = 1;

    public CartItem() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public double getTotalPrice() {
        return price * ToTalCount;
    }

    public Integer getToTalCount() {
        return ToTalCount;
    }

    public void setToTalCount(Integer toTalCount) {
        ToTalCount = toTalCount;
    }

    public CartItem(Integer id, String name, Double price, Integer toTalCount) {
        this.id = id;
        this.name = name;
        this.price = price;
        ToTalCount = toTalCount;
    }

    @Override
    public String toString() {
        return "CartItem{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", price=" + price  +
                ", ToTalCount=" + ToTalCount +
                '}';
    }
}
```



//购物车类

``` java
public class Cart {

    //map用于存储各种图书商品
    Map<Integer, CartItem> map = new HashMap<>();
    public Map<Integer, CartItem> getMap() {
        return map;
    }

    public void setMap(Map<Integer, CartItem> map) {
        this.map = map;
    }

    //加入购物车
    public void addCart(CartItem cartItem) {

        CartItem item = map.get(cartItem.getId());
        if (item == null){
            map.put(cartItem.getId(),cartItem);
        } else {
            item.setToTalCount(item.getToTalCount() + 1);
            map.put(item.getId(),item);
        }

    }

    //删除当前商品
    public void delete(Integer id) {
        map.remove(id);
    }

    //清空购物车
    public void clear(){
        map.clear();
    }

    //修改商品数量
    public void update(Integer id,Integer count) {

        CartItem cartItem = map.get(id);
        cartItem.setToTalCount(count);
    }

    //获取总的商品数量
    public Integer getTotalCount() {
        Integer TotalCount = 0;
        for (Map.Entry<Integer,CartItem> map : map.entrySet()) {
            TotalCount += map.getValue().getToTalCount();
        }

        return TotalCount;
    }

    //获取总的价格
    public double getTotalPrice() {
        double TotalPrice = 0;
        for (Map.Entry<Integer,CartItem> map : map.entrySet()) {
            TotalPrice += map.getValue().getTotalPrice();
        }

        return TotalPrice;
    }

}

web层：
    public class CartServlet extends BaseServlet{

    BookServiceImpl bookService = new BookServiceImpl();

    protected void addCart(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //获取图书对象
        int bookId = WebUtils.parseInt(req.getParameter("bookId"),1);
        Book book = bookService.getBookById(bookId);
        //将图书对象转换成商品对象
        CartItem cartItem = new CartItem(book.getId(), book.getName(), book.getPrice(), 1);
        //首先从session中获取购物车对象
        Cart cart = (Cart) req.getSession().getAttribute("cart");

        if (cart == null) {
            cart = new Cart();
            req.getSession().setAttribute("cart",cart);
        }
        cart.addCart(cartItem);
        System.out.println(req.getHeader("Referer"));
        resp.sendRedirect(req.getHeader("Referer"));
    }


    protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        Cart cart = (Cart) req.getSession().getAttribute("cart");
        int bookId = WebUtils.parseInt(req.getParameter("bookId"), 0);
        cart.delete(bookId);
        resp.sendRedirect(req.getHeader("Referer"));

    }


    protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //获取参数
        int itemCount = WebUtils.parseInt(req.getParameter("itemCount"), 1);
        int bookId = WebUtils.parseInt(req.getParameter("bookId"), 11);
        //获取购物车对象
        Cart cart = (Cart) req.getSession().getAttribute("cart");
        cart.update(bookId,itemCount);
        resp.sendRedirect(req.getHeader("Referer"));

    }


    protected void clear(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        Cart cart = (Cart) req.getSession().getAttribute("cart");
        cart.clear();
        resp.sendRedirect(req.getHeader("Referer"));
    }
}
```



​	上面的购物车是用户在当前浏览器上进行了操作之后就有的，所以我们吧购物车存储在session域中。因为session域的特点是在当前浏览器被关闭前都会存活，所以在用户关闭浏览器前session的对象不会消失。



## 订单实现



​	Order模型

1. 每个订单都有自己的顾客号
2. 订单生成的时间
3. 订单的价格
4. 订单号



​	OrderItem具体某一类订单

1. 订单号
2. 订单名称
3. 订单的单价
4. 订单的数量
5. 订单的总价
6. 订单的自带id



​	首先就是在数据库中创建两个模型

```sql
CREATE TABLE t_order(
	orderId VARCHAR(50) PRIMARY KEY,
	create_time DATETIME,
	price DOUBLE,
	user_id INT,
	FOREIGN KEY (user_id) REFERENCES t_user(id)
)

CREATE TABLE t_order_item(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	COUNT INT,
	price DOUBLE,
	total_price DOUBLE,
	order_Id VARCHAR(50),
	FOREIGN KEY (order_Id) REFERENCES t_order(orderId)
)
```



### 生成订单



​	当用户点击去结账之后，请求转发到servlet程序的生成订单方法，name生成订单具体是要做些什么呢？

​	首先生成订单肯定是要获取用户买了些什么，也就是上面建立的orderItem模型，这样才能发货呀；其次每次订单生成之后肯定是要来一个总计的，也就是上面的order模型。所以这是需要操作数据库的。

​	servlet程序---》service层------》Dao层

```java
Dao层：
    @Override
    public int saveOrder(Order order) {

        String sql = "insert into t_order values(?,?,?,?)";
        return update(sql,order.getOrderId(),order.getOrderTime(),order.getPrice(),order.getUserId());
    }

	@Override
    public int saveOrderItem(OrderItem orderItem) {

        String sql = "insert into t_order_item values(?,?,?,?,?,?)";
		return 	update(sql,orderItem.getId(),orderItem.getName(),orderItem.getCount(),
                      	orderItem.getPrice(),orderItem.getToTalPrice(),orderItem.getOrderId());
    }
```



​	怎么样才能获得上面方法的参数呢？

​	orderItem这是具体的商品，是可以遍历cart购物车获取的，而order的属性有userId，所以需要在session域中获取用户（一般用户登录之后的所有操作产生的有效数据保存到session域中），然后就是datetime属性，可以直接创建日期兑现即可，总结个可以在cart获取，orderId是订单号，我们是要获取一个唯一的订单号的，一般System.currentTimeMills()获取的好描述是唯一的，但是防止有些用户可能在同一时间结账，所以需要再加上一个userId，这样就能确保唯一性了。所以根据分析，service层的方法只需要获取两个参数，cart和userId，就可以实现Dao层数据库的保存操作了。

```java
service层：
    public String createOrder(Cart cart, Integer userId) {

        String orderId = System.currentTimeMillis() + userId + "";
        Order order = new Order(userId, new Date(), cart.getTotalPrice(), orderId);
        orderDao.saveOrder(order);

        for (Map.Entry<Integer, CartItem> item : cart.getMap().entrySet()){

            CartItem cartItem = item.getValue();
            OrderItem orderItem = new OrderItem(cartItem.getId(), cartItem.getName(), cartItem.getPrice(), 											cartItem.getToTalCount(), (int) cartItem.getTotalPrice(), orderId);
            orderItemDao.saveOrderItem(orderItem);

            //订单完成后肯定是要更新图书信息的，销量增加，存货减少
            Book book = bookService.getBookById(cartItem.getId());
            book.setSales(book.getSales() + cartItem.getToTalCount());
            book.setStock(book.getStock() - cartItem.getToTalCount());
            bookService.update(book);
        }

        return orderId;
    }

web层：
    protected void createOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //首先判断用户是否登录，不然不能结账
        User user = (User) req.getSession().getAttribute("user");
        if (user == null) {
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req,resp);
            return;
        }

        Integer userId = user.getId();
        Cart cart = (Cart) req.getSession().getAttribute("cart");
        String orderId = orderService.createOrder(cart, userId);
        req.getSession().setAttribute("orderId",orderId);
        //结完账之后清空购物车
        cart.getMap().clear();
        req.getRequestDispatcher("/pages/cart/checkout.jsp").forward(req,resp);
    }
```



### （用户）查看订单



​	嗯，查看订单肯定是要在用户登录之后才能操作的，不然查个鬼...

​	查看order，那肯定是要操作书库的，根据每个用户的id查询

```sql
select orderId,create_time createTime,price,user_id userId from t_order where user_id = ?
```

* 这里需要注意一个点，**对数据库中带有下换线的字段查询时必须要起一个别名，而且别名必须要和对应的实体类属性名一致**。
  * 例如：create_time  起个别名 createTime，而对应的Order类的一个属性名也必须是createTime才行
  * 不然的话是带有下划线的字段返回地是空值

​    

​	这样就能根据用户查询到用户下过的订单了

```java
Dao层：
    public List<Order> getOrder(Integer userId) {
        String sql = "select orderId,create_time createTime,price,user_id userId from t_order where user_id 						= ?";
        List<Order> orders = queryMul(sql, Order.class, userId);
        return orders;
    }

service层：
    public List<Order> getOrder(Integer userId) {
        List<Order> orders = orderDao.getOrder(userId);
        return orders;
    }

web层：
    protected void getOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    	//查看订单肯定是要登录的
        User user = (User) req.getSession().getAttribute("user");
        if (user == null){
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req,resp);
            return;
        }
        Integer userId = user.getId();
        List<Order> orders = orderService.getOrder(userId);
        req.getSession().setAttribute("orders",orders);
    	//跳转到登录页面
        req.getRequestDispatcher("/pages/order/order.jsp").forward(req,resp);
    }

```



​	然后在jsp页面上遍历即可	

```jsp
<tr>
    <td>日期</td>
    <td></td>
    <td>订单号</td>
    <td>金额</td>
    <td>状态</td>
    <td>详情</td>
    <td>操作</td>
</tr>
//判断用户是否有过订单，有才遍历，没有的话就给个提示
<c:if test="${sessionScope.orders.size() > 0}">
    <c:forEach items="${sessionScope.orders}" var="order">
        <tr>
            <td colspan="2">${order.orderTime}</td>
            <td>${order.orderId}</td>
            <td>${order.price}</td>
            <td>已发货</td>
            <td><a href="orderServlet?action=checkOrder">查看详情</a></td>
            <td><a class="sureGetItem" href="orderServlet?   		action=deleteOrder&orderId=${order.orderId}">确认收货</a></td>
        </tr>
    </c:forEach>
</c:if>
<c:if test="${sessionScope.orders.size() == 0}">
    <tr>
        <td colspan="7">您当前还没有订单哦，请<a href="index.jsp">前往首页</a>挑选商品吧~~</td>
    </tr>
</c:if>
```



### 查看订单详情



​	其实查看订单详情，还是操作数据库

```sql
select id,name,price,count,total_price as totalPrice,order_Id as orderId from t_order_item where order_Id = ?
```



​	由此可见，只需要订单号就可以查到订单详情：

```java
Dao层：
    public List<OrderItem> getOrderItem(Order order) {

        String sql = "select id,name,price,count,total_price as totalPrice,order_Id as orderId from t_order_item where order_Id = ?";
        return queryMul(sql,OrderItem.class,order.getOrderId());
    }

service层：
    public List<OrderItem> checkOrderItem(Integer userId) {
        List<Order> orders = orderDao.getOrder(userId);
        List<OrderItem> orderItems = new ArrayList<>();
    	//每一个订单都有很大可能有多个商品，所以需要遍历该用户所有订单的所有商品，加入到一个集合中
        for (Order order : orders) {
            List<OrderItem> orderItem = orderDao.getOrderItem(order);
            for (OrderItem item : orderItem) {
                orderItems.add(item);
            }
        }
        return orderItems;
    }

web层：
    protected void checkOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    	//这部分判断其实可以封装成一个方法，当成工具类使用
        User user = (User) req.getSession().getAttribute("user");
        if (user == null){
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req,resp);
            return;
        }
        Integer userId = user.getId();
        List<OrderItem> orderItems = orderService.checkOrderItem(userId);
        req.getSession().setAttribute("orderItems",orderItems);
        req.getRequestDispatcher("/pages/order/checkOrder.jsp").forward(req,resp);
    }
```



​	然后再jsp页面中输出即可

```jap
<tr>
  <td>名称</td>
  <td>单价</td>
  <td>数量</td>
  <td>总价</td>
</tr>
  <c:if test="${sessionScope.orderItems.size() > 0}">
      <c:forEach items="${sessionScope.orderItems}" var="orderItem">
          <tr>
            <td>${orderItem.name}</td>
            <td>${orderItem.price}</td>
            <td>${orderItem.count}</td>
            <td>${orderItem.toTalPrice}</td>
          </tr>
      </c:forEach>
  </c:if>
```



### 确认收货



​	嗯，在我的理解中，一旦用户确认收货了，就把该项订单给删了...

​	那么，第一件事还是给确认收货这个超链接来个事件绑定，提示用户是否确认一下收货；当然还是要给servlet程序传一个orderId的参数的

```javascript
$(function (){
		$(".sureGetItem").click(function (){
			return confirm("您确定收到货了？");
		})
}
```



​	然后就可以想一想删库跑路的语句了

* 这里还是要注意一个问题，t_order_item中存在来自t_order的外键，所以必须先删t_order_item再能删t_order，不然是删不了的

```sql
delete from t_order_item where order_id = ?
delete from t_order where orderId = ?
```

​	so，代码实例：

```java
Dao层：
    public int deleteOrderItemByOrderId(String orderId) {
        String sql = "delete from t_order_item where order_Id = ?";
        return update(sql,orderId);
    }

	public int deleteOrderByOrderId(String orderId) {
        String sql = "delete from t_order where orderId = ?";
        return update(sql,orderId);
    }

service层：
    public int deleteOder(String orderId) {
        orderItemDao.deleteOrderItemByOrderId(orderId);
        return orderDao.deleteOrderByOrderId(orderId);
    }

web层：
    protected void deleteOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        String orderId = req.getParameter("orderId");
        orderService.deleteOder(orderId);
    	//回到原来的页面
        resp.sendRedirect(req.getHeader("Referer"));
    }
```



​	嗯，后台的订单管理其实也差不了太多，我这里吧order类的一个属性给删了，status属性，用来表示订单是否发货，偷个小懒...

## 事务管理



​	上面的订单模块算是粗糙的完成了，但是，同志们，我们需要注意一个问题！！！

​	createOrder的时候我们是先生成了订单类，再生成了具体的订单物品，也就是orderItem类，这两者之间是必须都要生成的。如果两者之间有那么一句代码写错了，就会造成一个很大的问题，只生成了订单，却没有订单的具体物品，那还怎么发货，生意都做不下去了，肯定要被投诉的！！不仅仅是这个地方，删除订单的时候也是要一起完成的，甚至是全部的程序，应该都保持一个标准，要么一起成功，要么一起失败。

​	所以我们应该应用JDBC来进行事务管理。而要想进行事务管理，就必须使用同一个连接（connection），并且在这个过程中不能在某一功能完成之后就把连接资源关闭，必须等所有功能完成在进行事物的提交或者回滚，并关闭连接。还要注意一点的是，整个过程中捕获的异常都要往外抛，不然可能会造成回滚事务失败，因为捕获不到异常，直接提交事务。

​	例如：

```java
 Order order = new Order(userId, new Date(), cart.getTotalPrice(), orderId);
//保存订单
 orderDao.saveOrder(order);

 int x = 12/0;

//保存订单商品
....
```

 在经过12/0的时候，下面的语句都不能正常进行了，如果在这个过程中，有那么一段代码捕获到了这个异常

例如：

```java
web层：
    try{
        ...
    } catch(Exception e){
        //异常被抓住了，提交事务的时候没有这个异常了，完蛋，直接给你提交事务了，有一场也不会回滚了，这个时候就只有订单，没有具体的商品了。
    }
```

so，我们每次抓到的异常都要抛出去，交给JDBC处理



修改JDBC

```java
pubilc class JDBCUtils{
    private static DataSource datasource = null;
    //利用ThreadLocal线程，保证同一线程中的connection都是一样的
    private static ThreadLocal<Connection> conns = new ThreadLocal<>();
    
    //类加载之后就记载，获取连接池
    static{
        Properties properties = new Properties();
        try{
            //加载配置文件
            properties.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
            //利用Druid连接池工厂类初始化驱动
            dataSource = DruidDataSourceFactory.createDataSource(properties);
        } catch(Exception e){
            e.printStackTrace();
        }
    }
   
    public static Connection getConnection{
        Connection connection = cons.get();
        if (connction == null){
        try{
           connection = dataSource.getConnection(); 
           conns.set(connection);
           //将自动提交事务关闭
            connection.setAutoCommit(false);
        }
         catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        return connection;
    }
    
    //提交事务并且关闭连接
     public static void commitAndClose(){

        Connection connection =  conns.get();
        if (connection != null) {
            try {
                connection.commit();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }finally{
                try {
                    connection.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
         //将连接去掉，tomcat底层是用了连接池技术，不然会出错的
        conns.remove();
    }
        
         //提交事务并且关闭连接
     public static void commitAndClose(){

        Connection connection =  conns.get();
        if (connection != null) {
            try {
                connection.rollback();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            } finally{
                try {
                    connection.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
        conns.remove();
    }
}
```



​	然后就是在basicDao类中将connection.close()去掉，并且把捕获到异常往外面抛出去(throw new RuntimeException(e))

​	在所有捕获异常的地方都要往外面抛。

​	新建一个AllFilter类继承javax.servlet.Filter过滤器，用于拦截所有的程序

​	配置web.xml

```xml
<filter>
        <filter-name>AllFilter</filter-name>
        <filter-class>com.dajiao.filter.AllFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>AllFilter</filter-name>
        <!--    拦截所有路径    -->
        <url-pattern>/*</url-pattern>
    </filter-mapping>
```



```java
import com.dajiao.utils.JDBCUtils;
import javax.servlet.*;
import java.io.IOException;

public class AllFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {

        try {
            chain.doFilter(req, resp);
            JDBCUtils.commitAndClose();
        } catch (Exception e){
            JDBCUtils.rollbackAndClose();
            e.printStackTrace();
            //将异常抛给tomcat服务器，统一管理
            throw new RuntimeException(e);
        }
    }
    @Override
    public void destroy() {

    }
}

```



大功基本告成！



## 使用tomcat统一管理页面异常

​	可以在新建一个web下error的文件，里面放着error500.jsp

​	配置web.xml

```xml
<error-page>
        <error-code>500</error-code>
    	<!--   当出现500错误后的跳转页面   -->
        <location>/pages/error/error500.jsp</location>
    </error-page>
```

比如上方的，就是程序内部错误，我们需要来一点友好的错误提示

```jsp
<%@include file="/pages/common/head.jsp"%>
不好意思，你你访问的网站出了问题，程序猿小哥哥正在努力抢修中，请耐性等待~~~
<a href="index.jsp">返回首页</a>
```



## 总结

​	稍微总结一下上面用到的知识：

​	HttpServletRequest的作用：

1. 可以转发请求
2. 可以保存数据
3. 可以获取请求参数
4. 可以获取请求头
5. 可以设置参数的字符集，防止中文乱码



​	HttpServletResponse的作用：

1. 重定向



​	session的作用：

1. 用户在页面上的一系列跟用户有关的有效数据都保存到session域中，因为这些数据有可能在很多页面上可以用到，所以需要保存在session域中，如果保存到request是不行的因为request中的数据只是一次请求内有效，而session确实关闭浏览器之前都有效



​	EL表达式和JSTL标签的混合使用

1. 在页面上有很多次的遍历输出，都是用了EL表达式输出，JSTL标签遍历
2. JSTL标签还有一个很有用的判断语句，用于判断有些页面内容是否需要输出



​	JavaScript的事件处理

1. 页面加载完成事件
2. 点击事件
3. 内容改变事件
4. 失去焦点事件
5. 还有一些获取标签的jQuery选择器使用
6. confirm函数的使用
7. location.href属性的使用



​	JDBC获取连接

1. 利用Durid获取连接池
2. 获取连接方法
3. 关闭连接方法



​	Dbutils的使用

1. QueryRunning类的使用
2. 增删改查的编写



​	AjAx的使用

1. $.getJson(url,data,function(){})，可以用来验证用户名的唯一性



​	Filter过滤器：

1. 前置代码
2. chain.doFilter(req,resp)，跳转到下一个过滤器或者是对应的资源路径
3. 后置代码



​	谷歌验证码的使用

1. 导包
2. 在web.xml中配置地址
3. 直接在验证码图片资源src属性=web.xml的地址
4. 然后处理验证码点击事件，实时更新验证码
5. 在session域中获取验证码，并且立即删除



​	事务管理

1. 关闭自动提交事务
2. 需要使用一个连接
3. 整个事务过程中捕获的异常都需要抛出



​	Tomcat的统一处理异常

1. 配置web.xml文件，error-page



​	处理问题时一般从操作数据库出发思考，看看需要什么参数，再从页面上抽丝剥茧，将参数传递给web层，再创递给service层，最后传递到Dao层。





